<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Terminal TDD</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm/css/xterm.css" />
  <link rel="stylesheet" type="text/css" href="{{cssUri}}" />
  <script src="https://cdn.jsdelivr.net/npm/xterm/lib/xterm.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit/lib/xterm-addon-fit.js"></script>
</head>
<body>
  <div id="timeline">
    <h3>TDDLab Timeline</h3>
    <div id="timeline-content">{{timelineContent}}</div>
  </div>

  <div class="terminal-wrapper">
    <div id="terminal"></div>
  </div>

  <script>
    const vscode = acquireVsCodeApi();

    let terminalContent = '';
    let currentCommand = '';
    let isExecuting = false;

    // Historial en memoria (y persistido en host)
    let commandHistory = [];
    let historyIndex = -1; // -1 = no navegando
    let lastPrompt = '';   // e.g. "C:\\proyecto > "

    // Fit addon
    const fitAddon = new FitAddon.FitAddon();

    const term = new Terminal({
      cursorBlink: true,
      scrollback: 10000,
      convertEol: true,
      theme: {
        background: '#1e1e1e',
        foreground: '#ffffff'
      }
    });
    term.loadAddon(fitAddon);

    const terminalElement = document.getElementById('terminal');
    term.open(terminalElement);

    // Ajustar tamaño con fit
    function doFit() {
      try {
        fitAddon.fit();
      } catch (e) {
        // ignore
      }
    }
    setTimeout(doFit, 50);
    window.addEventListener('resize', () => setTimeout(doFit, 50));

    function scrollToBottom() {
      requestAnimationFrame(() => {
        try { term.scrollToBottom(); } catch (e) {}
        if (term.element) {
          try { term.element.scrollIntoView({ block: 'end' }); } catch (e) {}
        }
      });
    }

    function resetCommandInput(promptText) {
      // \x1b[2K borra la línea completa, \r vuelve al inicio
      const writeText = '\x1b[2K\r' + (promptText || '');
      term.write(writeText);
    }

    // Guardar historial persistente en el host
    function saveHistory() {
      vscode.postMessage({ command: 'historyUpdate', history: commandHistory });
    }

    // Manejo de flechas (historial)
    function handleHistoryArrow(key) {
      if (commandHistory.length === 0) return;

      if (historyIndex === -1 && key === 'ArrowUp') {
        historyIndex = commandHistory.length - 1;
      } else if (key === 'ArrowUp') {
        historyIndex = Math.max(0, historyIndex - 1);
      } else if (key === 'ArrowDown') {
        if (historyIndex === -1) return;
        historyIndex++;
        if (historyIndex >= commandHistory.length) {
          historyIndex = -1;
        }
      }

      if (historyIndex === -1) {
        currentCommand = '';
        resetCommandInput(lastPrompt);
      } else {
        const newCmd = commandHistory[historyIndex] || '';
        currentCommand = newCmd;
        resetCommandInput(lastPrompt + newCmd);
      }
      scrollToBottom();
    }

    // --- Cambiado: usar term.onKey en vez de attachCustomKeyEventHandler
    term.onKey(({ key, domEvent }) => {
      // Manejar flechas una sola vez aquí
      if (isExecuting) {
        // prevenir comportamiento por defecto cuando está ejecutando
        try { domEvent.preventDefault(); } catch (e) {}
        return;
      }
      if (domEvent.key === 'ArrowUp' || domEvent.key === 'ArrowDown') {
        try { domEvent.preventDefault(); } catch (e) {}
        handleHistoryArrow(domEvent.key);
      }
      // para el resto de teclas dejamos que onData las procese
    });

    // Entrada de caracteres (enter, backspace, ctrl+c, imprimibles)
    term.onData(data => {
      if (isExecuting) return;

      // Enter
      if (data === '\r' || data === '\n') {
        term.write('\r\n');
        const trimmed = currentCommand.trim();
        if (trimmed) {
          // Añadir al historial (evitar duplicados consecutivos)
          const last = commandHistory.length ? commandHistory[commandHistory.length - 1] : null;
          if (!last || last !== trimmed) {
            commandHistory.push(trimmed);
            saveHistory(); // persistir en host
          }
        }
        historyIndex = -1;
        isExecuting = true;
        vscode.postMessage({ command: 'executeCommand', text: currentCommand });
        currentCommand = '';
        return;
      }

      // Backspace
      if (data === '\x7f' || data === '\b') {
        if (currentCommand.length > 0) {
          currentCommand = currentCommand.slice(0, -1);
          term.write('\b \b');
        }
        return;
      }

      // Ctrl+C
      if (data === '\x03') {
        term.write('^C\r\n');
        vscode.postMessage({ command: 'killCommand' });
        isExecuting = false;
        currentCommand = '';
        return;
      }

      // Ignorar secuencias de escape que puedan llegar (flechas u otros)
      if (data.startsWith('\x1b')) {
        return;
      }

      // Caracteres imprimibles
      if (data >= ' ' && data <= '~') {
        currentCommand += data;
        term.write(data);
      }
    });

    // Detectar prompt en el contenido
    function detectPromptFromTerminalContent() {
      const tail = terminalContent.slice(-2000);
      const m = tail.match(/(?:\r\n|\n)([^\r\n]+>\s*)$/);
      if (m) {
        lastPrompt = m[1];
        isExecuting = false;
        currentCommand = '';
        return true;
      }
      if (tail.endsWith('> ')) {
        const parts = tail.split(/(?:\r\n|\n)/).filter(Boolean);
        const last = parts[parts.length - 1];
        if (last && last.includes('>')) {
          lastPrompt = last;
          isExecuting = false;
          currentCommand = '';
          return true;
        }
      }
      return false;
    }

    // Mensajes desde la extension
    window.addEventListener('message', event => {
      const message = event.data;
      switch (message.command) {

        case 'writeToTerminal': {
          const text = message.text || '';
          term.write(text);
          terminalContent += text;
          vscode.postMessage({ command: 'contentUpdate', content: terminalContent });

          detectPromptFromTerminalContent();
          scrollToBottom();
          break;
        }

        case 'clearTerminal': {
          term.clear();
          terminalContent = '';
          currentCommand = '';
          isExecuting = false;
          lastPrompt = '';
          historyIndex = -1;
          // No limpiar historial automáticamente (pero podríamos si queremos)
          vscode.postMessage({ command: 'contentUpdate', content: terminalContent });
          scrollToBottom();
          break;
        }

        case 'restoreContent': {
          term.clear();
          const content = message.content || '';
          term.write(content);
          terminalContent = content;
          currentCommand = '';
          isExecuting = false;
          historyIndex = -1;
          detectPromptFromTerminalContent();
          scrollToBottom();
          break;
        }

        case 'restoreHistory': {
          // Recibir historial persistido desde el host
          const h = Array.isArray(message.history) ? message.history : [];
          if (h && h.length) {
            commandHistory = h.slice();
            historyIndex = -1;
          }
          break;
        }

        case 'scrollToBottom': {
          scrollToBottom();
          break;
        }

        default:
          // no reconocido
      }
    });

    // Avisar que la webview está lista
    vscode.postMessage({ command: 'webviewReady' });
    term.focus();
  </script>
</body>
</html>