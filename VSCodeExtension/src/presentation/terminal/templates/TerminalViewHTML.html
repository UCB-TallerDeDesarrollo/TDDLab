<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Terminal TDD</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm/css/xterm.css">
  <link rel="stylesheet" type="text/css" href="{{cssUri}}">
  <script src="https://cdn.jsdelivr.net/npm/xterm/lib/xterm.js"></script>
</head>
<body>
  <div id="timeline">
    <h3>TDDLab Timeline</h3>
    <div id="timeline-content">{{timelineContent}}</div>
  </div>

  <div class="terminal-wrapper">
    <div id="terminal"></div>
  </div>

  <script>
    const vscode = acquireVsCodeApi();
    
    // función para pedir el prompt real al backend
    function requestPrompt() {
      vscode.postMessage({ command: 'requestPrompt' });
    }

    const term = new Terminal({ 
      cursorBlink: true,
      cols: 80,
      rows: 30,
      theme: {
        background: '#1e1e1e',
        foreground: '#ffffff'
      },
      allowTransparency: false,
      convertEol: true
    });
    
    const terminalElement = document.getElementById('terminal');
    term.open(terminalElement);
    
    setTimeout(() => {
      const xtermRows = terminalElement.querySelector('.xterm-rows');
      if (xtermRows) {
        xtermRows.style.textAlign = 'left';
        xtermRows.style.paddingLeft = '0';
        xtermRows.style.marginLeft = '0';
        xtermRows.style.width = '100%';
      }
      const xtermScreen = terminalElement.querySelector('.xterm-screen');
      if (xtermScreen) {
        xtermScreen.style.textAlign = 'left';
        xtermScreen.style.paddingLeft = '0';
        xtermScreen.style.marginLeft = '0';
      }
    }, 100);
    
    const fitAddon = () => {
      const container = document.querySelector('.terminal-wrapper');
      if (container) {
        const width = container.offsetWidth;
        const height = container.offsetHeight;
        const cols = Math.floor((width - 20) / 9); 
        const rows = Math.floor(height / 17); 
        term.resize(cols, rows);
      }
    };
    
    window.addEventListener('resize', fitAddon);
    setTimeout(fitAddon, 200);
    
    // PIDE EL PROMPT AL BACKEND
    requestPrompt();
    setTimeout(() => {
      term.scrollToBottom();
      term.focus();
    }, 0);
    
    // Estado del cliente (webview)
    let command = '';
    let isExecuting = false;
    let history = [];
    let historyIndex = 0; // history.length significa "línea vacía"
    let prompt = ''; // último prompt recibido desde backend (ej: "d:\\... > ")

    // Redibuja la línea actual: borra la línea y escribe prompt + comando
    function redrawInput() {
      term.write('\x1b[2K\r' + prompt + command);
    }

    // Manejo de teclas usando onKey (más fiable para flechas y modificadores)
    term.onKey(e => {
      const ev = e.domEvent;
      const key = ev.key; // 'Enter', 'Backspace', 'ArrowUp', etc.
      // Enter
      if (key === 'Enter') {
        if (!isExecuting) {
          if (command.trim()) {
            isExecuting = true;
            history.push(command);
            historyIndex = history.length;
            vscode.postMessage({ command: 'executeCommand', text: command });
            command = '';
          } else {
            // pedir prompt de nuevo si la línea está vacía
            requestPrompt();
          }
        }
        ev.preventDefault();
        return;
      }

      // ArrowUp
      if (key === 'ArrowUp') {
        if (history.length === 0) { ev.preventDefault(); return; }
        historyIndex = Math.max(0, historyIndex - 1);
        if (historyIndex === history.length) {
          command = '';
        } else {
          command = history[historyIndex];
        }
        redrawInput();
        ev.preventDefault();
        return;
      }

      // ArrowDown
      if (key === 'ArrowDown') {
        if (history.length === 0) { ev.preventDefault(); return; }
        historyIndex = Math.min(history.length, historyIndex + 1);
        if (historyIndex === history.length) {
          command = '';
        } else {
          command = history[historyIndex];
        }
        redrawInput();
        ev.preventDefault();
        return;
      }

      // Backspace
      if (key === 'Backspace') {
        if (command.length > 0 && !isExecuting) {
          command = command.slice(0, -1);
          redrawInput();
        }
        ev.preventDefault();
        return;
      }

      // Ctrl+L (limpiar)
      if ((ev.ctrlKey || ev.metaKey) && (key === 'l' || key === 'L')) {
        vscode.postMessage({ command: 'clearTerminal' });
        ev.preventDefault();
        return;
      }

      // Ctrl+C
      if ((ev.ctrlKey || ev.metaKey) && key === 'c') {
        term.write('^C\r\n');
        vscode.postMessage({ command: 'killCommand' });
        isExecuting = false;
        ev.preventDefault();
        return;
      }

      // Carácter imprimible (ev.key suele contener el carácter si no es especial)
      // Filtramos teclas con modificadores (alt/ctrl/meta) y teclas no imprimibles
      if (!ev.ctrlKey && !ev.metaKey && !ev.altKey && key.length === 1 && !isExecuting) {
        command += key;
        term.write(key);
        ev.preventDefault();
      }
    });

    // Recibe mensajes desde extension host
    window.addEventListener('message', event => {
      const message = event.data;
      switch (message.command) {
        case 'updateTimeline':
          document.getElementById('timeline-content').innerHTML = message.html;
          break;

        case 'writeToTerminal':
          { 
            const text = message.text || '';
            term.write(text);

            // Mejor detección del prompt: buscamos un '> ' al final de la salida
            // y guardamos el texto de prompt (la última línea que termina con '> ')
            // Ej: "\r\nC:\path > "
            const promptMatch = /(?:\r?\n)([^\r\n]*> )$/.exec(text) || /([^\r\n]*> )$/.exec(text);
            if (promptMatch) {
              prompt = promptMatch[1];
              isExecuting = false;
              historyIndex = history.length;
            }

            setTimeout(() => {
              term.scrollToBottom();
              term.focus();
            }, 0);
            break;
          }

        case 'clearTerminal':
          term.clear();
          command = '';
          isExecuting = false;
          // después de limpiar pedimos prompt real al backend
          requestPrompt();
          setTimeout(() => {
            term.scrollToBottom();
            term.focus();
          }, 0);
          break;
      }
    });
  </script>
</body>
</html>